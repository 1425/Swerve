// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2471.Swerve;
import com.sun.squawk.util.MathUtils;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class SwerveModule implements Runnable {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private SpeedController twist;
    private SpeedController speed;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Thread t;
    Encoder twistEnc, speedEnc;
    PIDController twistController;
    double twistOffset = 0.0;
    String name;
    static DashboardPID twistDashboardPID;
    
    private double Px, Py;
    private double hyp, xPivot = 0.0, yPivot = 0;
    private double desiredPower = 0;
    private double desiredAngle = 0;
    private double handsOffAngle = 0;

    public SwerveModule(String _name, SpeedController _speedController, Encoder _speedEnc,
            SpeedController _twistController, Encoder _twistEnc, 
            double xPosition, double yPosition, double _handsOffAngle, 
            double _twistOffset )
    {
        name = _name;
        speed = _speedController;
        speedEnc = _speedEnc;
        twist = _twistController;
        twistEnc = _twistEnc;
        Px = xPosition;
        Py = yPosition;
        hyp = Math.sqrt((Px+xPivot)*(Px+xPivot) + (Py+yPivot)*(Py+yPivot));
        handsOffAngle = _handsOffAngle;
        twistOffset = _twistOffset;

        twistEnc.setDistancePerPulse(Math.PI * 2.0 / 1250.0);
        twistEnc.start();
        
        twistController = new PIDController(1.0, 0.0, 0.5, new PidThing(this), new PidThing(this));
        twistDashboardPID = new DashboardPID("Twist", twistController);
        twistController.setInputRange(-Math.PI, Math.PI);
        twistController.setOutputRange(-1.0, 1.0);
        twistController.setContinuous(true);
        twistController.setPercentTolerance(1.0);  //1=1%  15==15% etc  verified with docs
        
        t = new Thread(this);
        t.start();
    }
    
    public DashboardPID getTwistDashboardPID() {
        return twistDashboardPID;
    }
    
    public void setTwistOffset(double newVal) {
        twistOffset = newVal;
    }
    /**
     * @return the twist
     */
    public double getTwist() {
        double rtn = twistEnc.getDistance();
        rtn = rtn + twistOffset;
        while(rtn > Math.PI) {
            rtn = rtn - 2.0 * Math.PI;
        }
        while(rtn < -1.0 * Math.PI) {
            rtn = rtn + 2.0 * Math.PI;
        }
        return rtn;
    }

    /**
     * @param twist the twist to set
     */
    public void setTwist(double twist) {
       //System.out.println("SM twist: " + twist);
       twistController.setSetpoint(twist);
       twistDashboardPID.update();
    }

    /**
     * @return the speed
     */
    public double getSpeed() {
        return speed.get();
    }

    /**
     * @param speed the speed to set
     */
    public void setSpeed(double speed) {
        this.speed.set(speed);
    }
    
    double upperDeadBand = 0.15; // Was 0.15
    double lowerDeadBand = 0.1;
    double lastMotor = 0.0;
    public void setTwistMotor(double _motor) {
        double motor = _motor;
        lastMotor = motor;
        twist.set(motor * -1.0);
    }
    
    public void run() {
        twist.set(0.75);
        double last;
        
        do {
            last = twistEnc.getDistance();
            try {                    
                Thread.sleep(25);
                if(!DriverStation.getInstance().isDisabled()) {
                }
            }
            catch(Exception e) {
                System.out.println("SwerveModule thread sleep exception");
            }
        } while(twistEnc.getDistance() - last < 0.01);
        twist.set(0.0);
        twistController.enable();
        setTwist(0.0);
    }
    
    class PidThing implements PIDSource, PIDOutput {
        SwerveModule master;
        public PidThing(SwerveModule _master) {
            master = _master;
        }
        public double pidGet() {
            //SmartDashboard.putNumber("Twist Error", twistController.getError());
            //System.out.println(name + "Twist: " + getTwist());
            return master.getTwist();
        }
        public void pidWrite(double out) {
            master.setTwistMotor(out);
//            System.out.println(master.name + "pidWrite: " + out);
        }
    }
    
    double Rx(double rotation) {
        return (rotation * (Py + yPivot) / hyp);
    }
    double Ry(double rotation) {
        return (rotation * -(Px + xPivot) / hyp);
    }
    public void setXOffset(double newX) {
        xPivot = newX;
        hyp = Math.sqrt((Px+xPivot)*(Px+xPivot) + (Py+yPivot)*(Py+yPivot));
    }
    public void setYOffset(double newY) {
        yPivot = newY;
        hyp = Math.sqrt((Px+xPivot)*(Px+xPivot) + (Py+yPivot)*(Py+yPivot));
    }
    
    class Polar {
        double r;
        double theta;

        public Polar(double x, double y){
            r = Math.sqrt(x*x + y*y);
            theta = MathUtils.atan2(-x, y); // we want 0 degrees to be in the Positive Y direction, which is towards the front of the robot
        }

        public double GetR()
        {
            return r;
        }

        public double GetAngle()
        {
            return theta;
        }

        public double GetX() {
            return -r*Math.sin(theta);
        }

        public double GetY() {
            return r*Math.cos(theta);
        }

        public void AddAngle( double angle ){
            theta = theta + angle;
        }
    }

    public double drive(double x, double y, double turnPower, double gyroAngle)
    {
        double reducedTurn = turnPower * 0.7;  // diminish turning, it was too fast
        
        Polar polar = new Polar(x,y);   // convert strafe to polar
        polar.AddAngle( -gyroAngle );  // add to convert the strafe request from field to robot space

        double vecX = polar.GetX() + Rx(reducedTurn);  // combine strafing with turning via vector addition
        double vecY = polar.GetY() + Ry(reducedTurn);
        
        // Convert vecX and vecY back to polar coords
        polar = new Polar( vecX, vecY );
        desiredAngle = polar.GetAngle();
        desiredPower = polar.GetR();
        FindNearestAngle( getTwist() );  // modifies both desiredAngle and desiredPower, prevents rotation of more than 90 degrees, reverses power if necessary
        
        setTwist(desiredAngle);
        return Math.abs(desiredPower);
    }
    public void SetMaxPower( double maxPower )
    {
        setSpeed( desiredPower / maxPower );
    }
    
    public void HandsOff()
    {
        setTwist( handsOffAngle );
        setSpeed(0.0);
    }
    
    void FindNearestAngle( double currentAngle )
    {
        double delta = desiredAngle - currentAngle;
        if (delta>Math.PI)
        {
            delta = delta - 2*Math.PI;
        }
        else if (delta<-Math.PI)
        {
            delta = delta + 2*Math.PI;
        }
        
        if (delta>Math.PI/2)
        {
            delta = delta - Math.PI;
            desiredAngle = currentAngle + delta;
            desiredPower = -desiredPower;
        }
        else if (delta<-Math.PI/2)
        {
            delta = delta + Math.PI;
            desiredAngle = currentAngle + delta;
            desiredPower = -desiredPower;
        }
    }
}
