// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2471.Swerve.subsystems;
import com.sun.squawk.util.MathUtils;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc2471.Swerve.*;
import org.usfirst.frc2471.Swerve.RobotMap;
import org.usfirst.frc2471.Swerve.commands.*;

public class SwerveDrive extends PIDSubsystem  {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SwerveModule rfModule, lfModule, rrModule, lrModule;
    double turnPower;
    double saveGyroAngle;
    double accelerometerAngle;
    double turnJoystickAngle;
    Filter accelFilter;
    DashboardPID steerDashboardPID;
    
    public DashboardPID getSteerDashboardPID() {
        return steerDashboardPID;
    }
    
    public SwerveDrive() {
        super("Steer PID", -1.5, -0.0, -6.0);
        steerDashboardPID = new DashboardPID( "Steer", getPIDController() );
        
        setInputRange( -Math.PI, Math.PI );
        getPIDController().setContinuous( true );
        setAbsoluteTolerance( Math.PI/180.0*5.0 );
        getPIDController().setOutputRange(-1.0, 1.0);
        enable();
        accelerometerAngle = 0.0;
        accelFilter = new Filter(5);
        
        lfModule = new SwerveModule("LF", RobotMap.leftFrontSpeed, RobotMap.leftFrontSpeedEnc, RobotMap.leftFrontTwist, RobotMap.leftFrontTwistEnc, 
            -16.0,11.0, Math.PI/4.0, (-0.42725 - 3.0*Math.PI/4.0 - 0.1361 + Math.PI/180*10));
        
        lrModule = new SwerveModule("LR", RobotMap.leftRearSpeed, RobotMap.leftRearSpeedEnc, RobotMap.leftRearTwist, RobotMap.leftRearTwistEnc,  
            -16.0,-11.0, -Math.PI/4.0, (0.18472 + 3.0*Math.PI/4.0 + 0.0471));
        
        rfModule = new SwerveModule("RF", RobotMap.rightFrontSpeed, RobotMap.rightFrontSpeedEnc, RobotMap.rightFrontTwist, RobotMap.rightFrontTwistEnc, 
            16.0,11.0, -Math.PI/4.0, (0.28902 + 3.0*Math.PI/4.0 + 0.096));

        rrModule = new SwerveModule("RR", RobotMap.rightRearSpeed, RobotMap.rightRearSpeedEnc, RobotMap.rightRearTwist, RobotMap.rightRearTwistEnc,
            16.0,-11.0, Math.PI/4.0, (0.54412 + Math.PI/4.0 - .1309));
    }
    
    public void drive(double x, double y, double r, double s, double gyroAngle, double accelX, double accelY)
    {
        steerDashboardPID.update();
        
        saveGyroAngle = gyroAngle;
        SmartDashboard.putNumber("gyroAngle", gyroAngle);
        
        if (Math.abs(accelX)>0.1 || Math.abs(accelY)>0.1) { 
            double temp = MathUtils.atan2(-accelX, accelY);
            accelFilter.AddSample(temp);
            accelerometerAngle = accelFilter.GetAverage();
            SmartDashboard.putNumber("accel angle", accelerometerAngle);
        }
        
        double magnitude = Math.sqrt( x*x + y*y );
        double turnMag = Math.sqrt( r*r + s*s );

        if (magnitude < 0.1 && turnMag < 0.05) {
            lrModule.HandsOff();
            lfModule.HandsOff();
            rrModule.HandsOff();
            rfModule.HandsOff();
            disable();
            return;
        }
        else
        {
            if (turnMag > 0.05) {
                turnJoystickAngle = MathUtils.atan2( -r, s );  // convert the right stick to a goal angle for robot orientation
                SmartDashboard.putNumber("joyStickAngle", turnJoystickAngle);
                setSetpoint( turnJoystickAngle );
                enable();
            }
            
            //setSetpoint( 0.0 );
        }

        //turnPower = r;  // joystick direct turning
        
        double lrPower = lrModule.drive(x, y, turnPower, gyroAngle);
        double lfPower = lfModule.drive(x, y, turnPower, gyroAngle);
        double rrPower = rrModule.drive(x, y, turnPower, gyroAngle);
        double rfPower = rfModule.drive(x, y, turnPower, gyroAngle);
        
        double maxPower = Math.max( 1.0, Math.max( lrPower, Math.max( lfPower, Math.max( rrPower, rfPower) ) ) );
        
        lrModule.SetMaxPower( maxPower );
        lfModule.SetMaxPower( maxPower );
        rrModule.SetMaxPower( maxPower );
        rfModule.SetMaxPower( maxPower );
    }
    
    public void initDefaultCommand() {
        setDefaultCommand(new DriveLoop());
    }
    
    protected double returnPIDInput() {
        return saveGyroAngle;
        //return accelerometerAngle;
    }
    
    protected void usePIDOutput(double output) {
        double error = getPIDController().getError();
        SmartDashboard.putNumber("TurnError", error);

        turnPower = output;
    }
}