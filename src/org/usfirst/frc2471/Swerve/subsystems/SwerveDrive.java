// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2471.Swerve.subsystems;
import com.sun.squawk.util.MathUtils;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import org.usfirst.frc2471.Swerve.*;
import org.usfirst.frc2471.Swerve.RobotMap;
import org.usfirst.frc2471.Swerve.commands.*;
/**
 *
 */
public class SwerveDrive extends PIDSubsystem  {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SwerveVector rfVect, lfVect, rrVect, lrVect;
    double turnPower;
    double saveGyroAngle;
    double accelerometerAngle;
    double turnJoystickAngle;
    
    public SwerveDrive() {
        super("Steering Controller", -0.65, -0.0, -0.2);
        setInputRange( -Math.PI, Math.PI );
        getPIDController().setContinuous( true );
        setAbsoluteTolerance( Math.PI/180.0*5.0 );
        getPIDController().setOutputRange(-1.0, 1.0);
        enable();
        
        lrVect= new SwerveVector(RobotMap.leftRearSwerve, -16.0,-11.0, -Math.PI/4.0); 
        lfVect= new SwerveVector(RobotMap.leftFrontSwerve, -16.0,11.0, Math.PI/4.0);  
        rrVect= new SwerveVector(RobotMap.rightRearSwerve, 16.0,-11.0, Math.PI/4.0); 
        rfVect= new SwerveVector(RobotMap.rightFrontSwerve, 16.0,11.0, -Math.PI/4.0);  
    }
    
    public void drive(double x, double y, double r, double s, double gyroAngle, double accelX, double accelY) {
        saveGyroAngle = gyroAngle;
        accelerometerAngle = MathUtils.atan2(-accelX, accelY);
        
        double magnitude = Math.sqrt( x*x + y*y );
        double turnMag = Math.sqrt( r*r + s*s );

        if (magnitude < 0.1 && turnMag < 0.05) {
            lrVect.HandsOff();
            lfVect.HandsOff();
            rrVect.HandsOff();
            rfVect.HandsOff();
            disable();
            return;
        }
        else
        {
            turnJoystickAngle = MathUtils.atan2( -r, -s );  // convert the right stick to a goal angle for robot orientation
            setSetpoint( turnJoystickAngle );
            //setSetpoint( 0.0 );
            enable(); // this is wrong. Is 's' valid joystick vertical??
//            System.out.println( "setPoint: " + turnJoystickAngle );  // this is wrong. Is 's' valid joystick vertical??
        }

        //turnPower = r;
        
        double lrPower = lrVect.drive(x, y, turnPower, gyroAngle, accelX, accelY);
        double lfPower = lfVect.drive(x, y, turnPower, gyroAngle, accelX, accelY);
        double rrPower = rrVect.drive(x, y, turnPower, gyroAngle, accelX, accelY);
        double rfPower = rfVect.drive(x, y, turnPower, gyroAngle, accelX, accelY);
        
        double maxPower = Math.max( 1.0, Math.max( lrPower, Math.max( lfPower, Math.max( rrPower, rfPower) ) ) );
        
        lrVect.SetMaxPower( maxPower );
        lfVect.SetMaxPower( maxPower );
        rrVect.SetMaxPower( maxPower );
        rfVect.SetMaxPower( maxPower );
    }
    
    public void initDefaultCommand() {
        setDefaultCommand(new DriveLoop());
    }
    
    protected double returnPIDInput() {
        return saveGyroAngle;
        //return accelerometerAngle;
    }
    
    protected void usePIDOutput(double output) {
        turnPower = output;
    }
}